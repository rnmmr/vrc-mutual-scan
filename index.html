<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewpoint" content="width=device-width, initial-scale=1.0">
    <title>好友关系网</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            font-family: Arial, sans-serif;
        }

        .dbox {
            flex-direction: column;
            height: auto;
            background: rgb(7, 36, 43);
            border: 2px solid rgb(5, 60, 72);
            color: rgb(106, 227, 249);
            display: flex;
            place-content: start space-between;
            -webkit-box-align: center;
            align-items: center;
            -webkit-box-pack: justify;
            border-radius: 8px !important;
            box-shadow: none !important;
            padding: 0px 7px !important;
            transition: all 0.2s ease 0s;
        }

        .dhover:hover {
            transition: all 0.2s ease 0s;
            background: rgb(7, 52, 63);
            border-color: rgb(8, 108, 132);
        }
    </style>
</head>

<body>
    <div style="display: flex; flex-direction: row;">
        <div id="dtop" style="display: flex;position: absolute; top: 5px;left:5px;z-index: 100;">
            <div id="dinput" style="display: flex;flex-direction: row">
                <label class="dbox dhover" for="dbtniff">导入结果</label>
                <input type="file" id="dbtniff" accept=".txt,.json" style="display: none;">
            </div>
        </div>
        <div id="graph" style="width:100%; height:100vh"></div>
    </div>
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <script>
        let nodes = null
        let edges = null
        let network = null
        document.getElementById('dbtniff').addEventListener('change', function () {
            const file = this.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const content = e.target.result;
                    const fdata = JSON.parse(content);
                    console.log(fdata);
                    nodes = getnode(fdata);
                    edges = getedge(fdata);
                    const options = {
                        nodes: {
                            shape: "dot",
                            size: 20,
                            font: {
                                color: "#000",
                                size: 14
                            }
                        },
                        //configure: {
                        //    enabled: true,
                        //    filter: "interaction",
                        //    showButton: true,
                        //},
                        edges: {
                            color: {
                                color: '#bbb',
                                highlight: '#2B7CE9',
                                hover: '#2B7CE9',
                            },
                            physics: true,
                        },
                        //physics: {
                        //    solver: "barnesHut",
                        //    stabilization: { iterations: 1200 },
                        //    
                        //    barnesHut: {
                        //        gravitationalConstant: -7000,  // 斥力更强
                        //        centralGravity: 0.25,          // 向中心吸引力
                        //        springLength: 130,             // 回弹长度
                        //        springConstant: 0.07,
                        //        avoidOverlap: 1                // 节点之间不会贴脸
                        //    }
                        //},
                        physics: {
                            enabled: true,
                            barnesHut: {
                                gravitationalConstant: -2000,   // 负得更大 → 排斥更强 → 更分散
                                centralGravity: 0.1,             // 拉回中心的力，越小越散
                                springLength: 400,               // 边的期望长度，越大越松
                                springConstant: 0.002            // 弹簧劲度，越小越软
                            },
                            stabilization: {
                                iterations: 0
                            }
                        },
                        layout: {
                            improvedLayout: true
                        },
                        //interaction: {
                        //    zoomSpeed: 0.5  // 默认是 1，改小变丝滑
                        //}
                    };
                    const dinput = document.getElementById("dtop");
                    dinput.innerHTML = `<input id="dsearch" type="text" onkeydown="if(event.keyCode==13){searchnode(this.value)}" placeholder="搜索好友">`; // 清空之前的图形
                    network = new vis.Network(document.getElementById("graph"), { nodes, edges }, options);
                    network.on("select", function (params) {
                        if (!params.nodes.length) {
                            resetHighlight();
                            return;
                        }
                        highlightnode(params.nodes[0])
                    });
                    function highlightnode(node) {
                        // 找出与该节点相连的节点
                        const connectedNodes = network.getConnectedNodes(node);
                        const allNodes = nodes.get();
                        // 重置所有节点样式
                        let resnode = [];
                        allNodes.forEach(n => {
                            resnode.push({
                                id: n.id,
                                color: { background: "#cccccc", border: "#bbb" }   // 灰暗
                            });
                        });
                        nodes.update(resnode);
                        let heightedNodes = [];
                        connectedNodes.forEach(id => {
                            heightedNodes.push({
                                id,
                                color: { background: "#97C2FC", border: "#2B7CE9" }   // 高亮颜色
                            });
                        });
                        nodes.update(heightedNodes);
                    }
                    window.highlightnode = highlightnode;
                    function resetHighlight() {
                        const allNodes = nodes.get();
                        let resnode = [];
                        allNodes.forEach(n => {
                            resnode.push({
                                id: n.id,
                                color: null   // 恢复默认外观
                            });
                        });
                        nodes.update(resnode);
                    }
                    //const visc = document.getElementsByClassName('vis-configuration-wrapper')[0];
                    //visc.style = "width: 600px; height: 100vh; overflow: auto; position: fixed; top:0px"
                    //var observer = new MutationObserver(function (mutations) {
                    //    mutations.forEach(function (mutation) {
                    //        if (mutation.type === "childList") {
                    //            const visc = document.getElementsByClassName('vis-configuration-wrapper')[0];
                    //            visc.style = "width: 600px; height: 100vh; overflow: auto; position: fixed; top:0px"
                    //        }
                    //    });
                    //});
                    //observer.observe(document.body, { childList: true, subtree: true });
                };
                reader.readAsText(file);
            }
        });
        function searchnode(id) {
            let nodeId;
            if (id.includes('usr_')) {
                nodeId = nodes.getIds().find(nid => nid.toString() === id);
            } else {
                const match = nodes.get({
                    filter: item => item.label && item.label.includes(id)
                })[0];
                nodeId = match ? match.id : null;
            }
            if (nodeId) {
                network.selectNodes([nodeId]);
                network.focus(nodeId, { scale: 1, animation: true });
                highlightnode(nodeId)
            } else {
                alert("未找到该节点");
            }
        }

        function getnode(jsondata) {
            let num = jsondata.length
            const nodes = new vis.DataSet();
            nodes.add({
                id: 'me', label: '我', size: 20 + num, x: 0, y: 0, mass: Math.log2(num + 2), fixed: { x: true, y: true }
            });
            for (const node of jsondata) {
                const ml = node.mutuals.length
                //                console.log(ml);
                nodes.add({ id: node.user, label: node.displayname, title: `${node.displayname},有${ml}位共同好友`, size: 20 + ml, mass: Math.log2(ml + 2) });//节点大小与互粉数相关
            }
            return nodes;
        }

        function getedge(jsondata) {
            let flist = [];
            for (const node of jsondata) {
                flist.push({ from: 'me', to: node.user });
                for (const m of node.mutuals) {
                    flist.push({ from: node.user, to: m.id });
                }
            }
            flist = deduplicateEdges(flist);
            const edges = new vis.DataSet();
            edges.add(flist);
            return edges;
        }

        function deduplicateEdges(flist) {
            const seen = new Set();
            const uniqueEdges = [];
            for (const edge of flist) {
                const sortedPair = [edge.from, edge.to].sort();
                const key = sortedPair.join(',');
                if (!seen.has(key)) {
                    seen.add(key);
                    uniqueEdges.push(edge);
                }
            }
            return uniqueEdges;
        }
        // 示例数据
    </script>

</body>

</html>
